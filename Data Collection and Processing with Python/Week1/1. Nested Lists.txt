Welcome back. In the past we've stuck in a few nested lists, but without ever really looking closely at what they are or how to work with them. Here we have a list called nested1, who's items are themselves lists. So, here's the first item a, b, c, a second item d e, and the third item is a list f, g, h. I'll talk about the whole list nested1 as the outer list, and each of these smaller lists inside as the inner lists. So, the first item in the outer list is an inner list a, b, c. I'm going to comment out some of the later lines of code here, and we'll work our way through it, seeing what the effect is of just one line at a time. On line two, we're printing the first item from the outer list, which is the first inner list a, b, c. Now I'm going to uncomment line three and run it. We're going to ask for the length of nested1. The length of that is three items. It's not a, b and c, it's item one, item two, and item three. So three items in nested1. I can append a new item as we've seen before, and nested1 is now going to have four items. The last item will be a list containing just i, and I can iterate through these lists, and print each of them out. So, this is going to print out all four of the lists. We get the first inner list, the second one, and the third one, and the fourth one. So, it's helpful to see the code lens representation of a nested list. Let's see this in code lens. So, when I assign this variable nested1 to have a nested list as its value, you can see it's printed representation. And it gets a little funny here because code lens is sometimes deciding to make an inner list be just shown right inside the outer list, and sometimes it's deciding that it doesn't really have room to put a, b, c here, so it's showing us the pointer to the inner list. So, nested1 again is a list of three items. The first item is this inner list, the second item is d e, and the third item is the inner list f, g and h. Let's see what happens if I append an item to each of the inner lists. So, nested1 square bracket zero, that's referring to the first inner list, and I'm going to append a new item to that, making it a, b, c and z. I'm also going to append something to the second inner list. Let's see what happens in code lens again. So, we get this original view of nested1 Of what the reference diagram looks like. Now what happens to that first inner list when I append Z to it? Well you'll see this odd thing has happened. Instead of having this pointer out to the other inner list, it's now magically decided that it has enough room to put it right here. So, this doesn't actually make any difference, it's just how code lens is choosing to show it to us, and it's put a fourth item in there. If we now see what happens when we append w to the second inner list, we find that it's now put that here and instead of keeping the list right in here, it's made a pointer out to here. So either way it's a way of representing that this item in the outer list is itself a list. We can put all the list items right in there, or we can make a pointer out to another inner list. So, these are two alternative ways that you can represent a nested list in these reference diagrams. You can do double indexing with two square brackets to pull an item out of an inner list. So, the first indexing we're going to do on line two is we say nested one square brackets one, that pulls out one of the inner lists, and y is now bound to that list containing d and e. On line three when I print y, I should just get the list d e as my output. On line four, if I ask for y square brackets zero, that should get me the first item in y. So, I should get d printing out. Now let's think about what happens on line six. On line six, I also have two square brackets but it's not delving into a big nested list. The first square brackets is actually used to define a list, to create a list. So, we create a list 10, 20 and 30, and then we pull out the item at position one, so what we should get as our output is 20. On line number seven we also have to square brackets, but in this case, before either of the square brackets we have nested1, which refers to this big list, the outer list that has inner lists as elements, and we are first grabbing the thing at square brackets one, and then we are from that, we are grabbing the thing at square bracket zero. So this is going to print D. How does Python know, in a situation like this when there are two square brackets, one after the other. Is it indexing twice to get inside an outer list and then inside an inner list, or is it as in line six, is it creating a list and then indexing into that list? And the answer is that, the Python interpreter can tell just by the context. If there's a list before the square bracket, then the square bracket means index go into that list. If there's no square bracket before it as with 10, 20, 30 on line six, then it means create a list. You already saw previously that we could append to a list even if it's a complicated list, but you can also assign values to positions in both the outer list and in inner lists. The way you do that is you make an expression that picks out a list position, like nested square bracket one, but you put it on the left side of an equals sign. On the right side you say what new value you want. So, line number two here is going to say nested square bracket one refers to the position where currently we have d and e, and it's going to replace that d and e with the list 1,2,3. And we can take that same logic one step further on line three. Nested square bracket one square bracket zero goes to the list that's at position one, and it finds within that inner list the item that's at position zero, and it replaces that item with the value 100. So, let's see what happens when we run this in code lens. But first we create this nested list. You can see there are four items. The first item is the inner list a, b, c, the second item is the inner list d e and so on. On line two when I replace nested one square bracket one with a new value, let's see what's going to happen. Notice what happens with the second item, it's now the list one, two, three. It used to be a list DE. Let's just back up in our execution and we'll see that. So, it used to be DE but when we move forward, that DE got replaced by the one, two, three. On line three, we're taking nested square bracket one square bracket zero. So, nested is this list. Position one is this list and position zero within that is right there, currently containing the value one. We're going to make that one be 100. Let's see that, see if that one becomes a 100 and sure enough it did. We can have other complex objects as list elements. For example, here each of the items is a dictionary. Let's see how Code Lens chooses to show that. So, we have a variable nested two. Its value is a list. That list has three items and each of those items is a dictionary. So, the first item nested inside of our outer list is a dictionary. It has two keys, a and b and each have values one and three. The second item in the list is also a dictionary. It has keys a, c and five. Here we have an even more nested list. Our task is to pull out the word willow, which is nested pretty far in here. It's not at the top level of the list, it's not even at the second level. You can see that here's one of the list items, and it has one of its values, the list of willow merchant Elm. Then willow is a list inside of that. We actually have one square bracket here, second square bracket, a third square brackets. So, we're three levels deep inside of the data structure, inside the variable data. So, if it's three levels in, we're actually going to need three square brackets total, to pull out the word willow from inside of data. Now, I'd like to develop my extraction expressions incrementally. That is, I'm going to do it a little bit at a time. I'm going to first make the expression that pulls out something from within that. I'm going to pull out a little more and then within that I'm going to pull out a little more. So, let's do that incrementally. You can see sort of my approach to writing code for something like this. Now they told us to name our variable plant. I'm going to say plant is data square brackets something. I'm going to just print plant to help myself see what I got. Now, what item am I going to get? Where am I going to index? Well, this is zero, one, index two, index three, four. Bacon is five. This inner list is six and this inner list which contains willow somewhere in it, is seven. So, that tells me I should extract data square brackets seven. Now, that's not going to get me just the word willow. I could try to make a more complicated expression, where I fill in the others right away but I do like to do this incrementally, because I might have counted wrong or whatever. Let's just see if I got the right kind of thing from data square brackets seven. So, I did pick out the right element from data. The right inner list, you can see that willows in here somewhere but I'm going to have to do another extraction. Since this is an exercise that has an auto checker for us, it's told us that we failed. We were supposed to get just willow but instead we got this list that somewhere has willow in it. So, we have a little more work to do. We knew we were going to have more work to do. So, inside data square brackets seven, I now have some help because I can see what it looks like, and it's actually in the first element, square bracket zero. So, I'll do this and check, make sure I still have it right. Sure enough. While I was in that and which element is it? Position zero, one, two. I want willow. So, I'm going to say square bracket zero. Sure enough. I now have just willow, which is what I was looking for. The test tells us that we passed. So, when you see something like square brackets seven, square bracket zero, square bracket zero, that means you're descending several layers into a complicated data structure. The best way to create expressions like that is to just do it one at a time, and keep building it up until you've descended farther and farther into the list. That's nested list. You can index into them with repeated use of the square brackets or you can assign values or append deep inside the nesting. You can say something like data square bracket seven, square bracket zero.append of some other value or you can say data square brackets seven, square bracket zero and have that on the left side of an assignment statement. The append will assume that there is a list at data square bracket seven square bracket zero and it'll give that list another item at the end, 29. If we just do an assignment statement, we will replace whatever's there, even if it's a whole list, it's just going to replace it with one new value, 42. See you next time.